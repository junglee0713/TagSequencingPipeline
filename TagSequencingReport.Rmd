---
title: "Basic Bioinformatics Overview"
author: "PennCHOP Microbiome Program"
date: "May 20, 2016"
output: pdf_document
---
# 16S Project Report
```{r setup, echo=FALSE}
#Creates figure image files in Knit folder
library(knitr)
opts_chunk$set(
  tidy=FALSE,
  cache=F,
  echo=F,
  dpi=100,
  fig.width=6,
  dev=c("png", "pdf"))
```

# Introduction
INSERT PROJECT DESCRIPTION HERE

```{r load scripts, echo=FALSE, message=FALSE}
#Load scripts for 16S analysis
library(qiimer)
library(pander)
library(ape)
library(vegan)
library(ggplot2)
library(plyr)
library(dplyr)
library(reshape2)
library(kylemisc)
```

```{r define_functions}
make_pcoa_plot <- function(uu, s, shape_by, color_by, title) {
  uu_pcoa <- pcoa(uu)
  uu_df <- merge(s, uu_pcoa$vectors[, 1:5], by.x="SampleIDorig", by.y="row.names")
  #uu_df <- cbind(s[s$Keep,], uu_pcoa$vectors[, 1:5])
  uu_pct <- round(uu_pcoa$values$Relative_eig * 100)

  g_uu = ggplot(uu_df, aes(x=Axis.1, y=Axis.2)) +
    #coord_equal() +
    theme_bw() +
    xlab(paste0("PCoA axis 1 (", uu_pct[1], "%)")) +
    ylab(paste0("PCoA axis 2 (", uu_pct[2], "%)")) +
    scale_shape_discrete(name=sub("_", " ", shape_by)) + 
    scale_colour_discrete(name=sub("_", " ", color_by)) +
    ggtitle(title)

  if (is.null(shape_by) & !is.null(color_by)) {
    g_uu <- g_uu + geom_point(aes(colour=factor(get(color_by))))
  } else if (!is.null(shape_by) & !is.null(color_by)) {
    g_uu <- g_uu + geom_point(aes(colour=factor(get(color_by)), shape=factor(get(shape_by))))
  } else {
    g_uu <- g_uu + geom_point()
  }
  return(g_uu)
}
```


```{r define_constants code, echo=FALSE}
# User defined variables
mapping_file_fp <- "mapping_file.tsv"

otu_table_fp <- file.path("otu", "otu_table.txt")
split_library_log_fp <- file.path("library", "split_library_log.txt")
uu_fp <- file.path("beta_diversity", "unweighted_unifrac_dm.txt")
wu_fp <- file.path("beta_diversity", "weighted_normalized_unifrac_dm.txt")

# Run parameters
min_reads <- 1000
```

```{r DeNOVO OTU code, echo=FALSE}
# Assign sample mapping file
s <- read_qiime_mapping_file(mapping_file_fp)

# Assign OTU table
o <- read_qiime_otu_table(otu_table_fp)

# Metadata in the form of truncated green genes assignments
md <- sub("(; [kpcofgs]__)+$", "", o$metadata, perl=T)

# Assignments data-frame
adf <- split_assignments(md)
a <- simplify_assignments(adf)

# Check if the sample names start with a number. If they do, add an "X" to the front
toFix = grepl("^[0-9]", s$SampleID)
s$SampleIDorig = s$SampleID
s$SampleID[toFix] = paste0('X', s$SampleID[toFix])

# Check for invalid sample IDs
problem_ids <- setdiff( colnames(o$counts), s$SampleID)
if (length(problem_ids ) > 0) stop (simpleError(paste("id mismatch found", problem_ids, collapse=" ")))

# check for the column names to assign color_by and shape_by for pcoa plots
color_by <- NULL
shape_by <- NULL
potential_headers <- c('study_group', 'study_day', 'current_antibiotics', 'cage_number', 'mouse_strain')
header_idx = which(is.element(potential_headers, colnames(s)))

if(length(header_idx)>0){
  color_by <- potential_headers[header_idx[1]]
}
if(length(header_idx)>1){
  shape_by <- potential_headers[header_idx[2]]
}

```

## --------------------------------------------------------

Samples were sequences on Miseq. Read pairs were quality filtered and joined to form a complete V1V2 amplicon sequence.  Operational Taxonomic Units (OTUs) were selected by clustering reads at 97% sequence similarity.  Taxonomic assignments will be generated by comparison to the Greengenes reference database, using the consensus method implemented in QIIME.  A phylogenetic tree will be inferred from the OTU data using FastTree. 

\newpage

## Histogram of high quality paired reads per sample

The vertical line shows the minimum number of reads for analysis.

```{r histogram, fig.width=7, fig.height=5, echo=FALSE}
read_counts <- read.csv(split_library_log_fp, sep="\t", skip=15, strip.white = FALSE, blank.lines.skip = TRUE,  header=FALSE, col.names=c("SampleID", "Read Counts"), stringsAsFactors = FALSE)

read_counts <- read_counts[1:(nrow(read_counts)-2),]
read_counts <- read_counts[order(read_counts$SampleID), ]
rownames(read_counts) <- NULL

toFix = grepl("^[0-9]", read_counts$SampleID)
read_counts$SampleID[toFix] = paste0('X', read_counts$SampleID[toFix])

s = merge(s, read_counts, by="SampleID", all.x = TRUE)

ggplot(s, aes(x=Read.Counts)) +
    geom_histogram(binwidth=10000) +
    geom_vline(xintercept = min_reads) +
    theme_classic() +
    theme_bw() + 
    xlab("Number of reads in sample") +
    ylab("Number of samples")

```

## Whole samples that are above the 1000 read count threshold
```{r}
## Whole samples discarded that are below the read count threshold of 1000
s$Keep <- s$Read.Counts > min_reads
s$Keep[grep("geneblock|extraction", s$SampleID, ignore.case = TRUE)] <- FALSE
s$KeepLabel <- factor(ifelse(s$Keep, "Keep", "Discard"))
keep_table <- table(s[,color_by], s$KeepLabel)
pander(keep_table,caption = "samples lost during prep and sequencing")
```

```{r echo=FALSE}
# Assignment counts per SampleID
cts <- o$counts[,s$SampleID[s$Keep]]

# filter the unassigned
is_mitochondrial <- grepl("mitochondria", adf$Family)
is_chloroplast <- grepl("Chloroplast", adf$Class)
is_unassigned <- grepl("Unassigned", adf$Kingdom)
is_contam <- is_mitochondrial | is_chloroplast | is_unassigned
write.table(a[is_contam], file="excluded_otus.tsv", quote=F, sep='\t')
cts <- cts[!is_contam,]
a <- a[!is_contam]
adf <- adf[!is_contam,]
rm(is_contam, is_mitochondrial, is_chloroplast, is_unassigned)
```

## Taxonomic Heatmap
The most specific taxonomic assignment available for each read is shown. Taxa are included in the plot if more than 1000 observations are made across the entire dataset. "Unassigned" reads did not match any 16S sequence in the reference database at a similarity threshold of 90%
Taxa are grouped by lowest common ranks for each OTU. Ranks are included in the plot if the combined OTUs reach 1000 observations together.
```{r overall_heatmap_annotations, echo=FALSE}
annotations <- NULL
if (is.null(shape_by) & !is.null(color_by)) {
  s <- arrange_(s, color_by) 
  annotations <- data.frame(s[,c(color_by)], row.names = s$SampleID) %>%
    setNames(color_by)
} else if (!is.null(shape_by) & !is.null(color_by)) {
  s <- arrange_(s, color_by, shape_by) 
  annotations <- data.frame(s[,c(color_by, shape_by)], row.names = s$SampleID) %>%
    setNames(c(color_by, shape_by))
}

cts <- cts[,s$SampleID[s$Keep]]
```

```{r Heatmap_by_study, fig.width=24, fig.height=15, echo=FALSE}
otu_heatmap(
  cts,
  a,
  annotation=annotations,
  threshold=1000,
  cluster_cols = FALSE, cluster_rows = FALSE,
  fontsize_col = 10, fontsize_row = 10,
  cellheight=10, cellwidth=10,
  legend = TRUE)

```


## Beta diversity measures

Similarity between samples were assessed by weighted and unweighted UniFrac distances. The first plot shows the distance between each pair of samples in a single 2D plot. It is not possible to plot the distances exactly on paper, so we have used a method of ordination called Principal Coordinates Analysis to select the best coordinate system for display. The percentage of total variance captured along each axis is displayed on the chart. It is typical for the percentage to be somewhat low if there are many samples, all different in a variety of ways. 

```{r Ordination_plots_uu, fig.width=6, fig.height=5, echo=FALSE, warning=FALSE}
uu <- read_qiime_distmat(uu_fp)
uu <- dist_subset(uu, s$SampleIDorig[s$Keep])
g_uu <- make_pcoa_plot(uu, s, shape_by, color_by, 'PCoA plot based on unweighted unifrac distances')
plot(g_uu)
```

The second plot shows sample clustering based on unweighted UniFrac distance. We have used a method of hierarchical clustering called "average-linkage" or UPGMA. At the bottom of the dendrogram, all samples start out in their own group. Moving up the dendrogram, samples accumulate into clusters if the average (mean) distance between all samples is below the indicated value.

```{r Cluster_by_study_uu, fig.width=6, fig.height=5, echo=FALSE}
hc = hclust(uu, method="average")
plot(hc, main="UPGMA linkage clustergram based on\nunweighted unifrac distances", xlab="", ylab="distance", sub = "")
```

\newpage

Here, we use weighted UniFrac distance to compare samples. Plots are described above.

```{r Ordination_plots_wu, fig.width=6, fig.height=5, echo=FALSE, warning=FALSE}
wu <- read_qiime_distmat(wu_fp)
wu <- dist_subset(wu, s$SampleIDorig[s$Keep])
g_wu <- make_pcoa_plot(wu, s, shape_by, color_by, 'PCoA plot based on\nweighted normalized UniFrac distances')
plot(g_wu)
```


```{r Cluster_by_study_wu, fig.width=6, fig.height=5, echo=FALSE}
hc = hclust(wu, method="average")
plot(hc, main="UPGMA linkage clustergram based on\nweighted normalized UniFrac distances", xlab="", ylab="distance", sub="")
```

\newpage

## APPENDIX: Counts of high quality paired reads for each sample for the whole lane
```{r}
pander(read_counts)
```
